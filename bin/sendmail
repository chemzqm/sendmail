#!/usr/bin/env node

var program = require('commander'),
    exec = require('child_process').exec,
    clog = require('clog'),
    fs = require('fs'),
    path = require('path'),
    sendmail = require('../');
    
program
  .version('0.1.2')
  .usage('[options] [number|filename]')
  .description('edit a new email and send if no arguments except profile exist')
  .option('-l --list', 'show all mails with filename number subject')
  .option('-e --edit <number|filename>', 'edit previous mail and send')
  .option('-s --send <number|filename>', 'send email without using vim to edit')
  .option('-d --delete <number|filename>', 'remove email, could be number separated by comma like: 0,1,2')
  .option('-c --cat <number|filename>', 'show email content, coulad be number separated by comma like: 0,1,2')
  .option('-g --grep <text>', 'grep text in all emails')
  .option('-p --profile <name>', 'use profile when sending email specified by name')
  .parse(process.argv);

var maildir = path.resolve(__dirname, '../mails');
function getEmails(cb){
  var child = exec('grep -r "^subject" .|sort -r',{
      cwd: maildir
    },
    function(err, stdout, stderr){
      if(err) clog.error(err);
      var lines = stdout.split('\n');
      for(var i=0; i < lines.length; i++){
        line = lines[i];
        var match = line.match(/^\.\/(\d+).+?subject:(.*)/);
        if(match){
          cb({
            number : i,
            name : match[1],
            subject : match[2]
          })
        }
      }
    }
  );
}

function cat(filename){
  exec('cat ' + filename ,{
    cwd : maildir
  },function(err, stdout, stderr){
    if(err) clog.error(err);
    console.log(stdout);
  });
}

function grep(text){
  exec('grep -r --color=always ' + text + ' .',{
    cwd : maildir
  },function(err, stdout, stderr){
    if(err) clog.error(err);
    console.log(stdout);
  });
}
var options = {
  profile: program.profile
};
if(program.list){
  console.log("file     number subject");
  getEmails(function(mail){
    console.log(mail.name + " " + mail.number + "      " + mail.subject);
  });
}
else if(program.delete){
  var ds = program.delete.split(',');
  getEmails(function(mail){
    if(~ds.indexOf(mail.number + '')){
      exec('rm '+ mail.name + '.email',{
        cwd : maildir
      },function(err){
        if(err) clog.error(err);
      });
    }
  });
}
else if(program.cat){
  if(/\.email$/.test(program.cat)){
    cat(program.cat);
    return;
  }
  var cs = program.cat.split(',');
  getEmails(function(mail){
    if(~cs.indexOf(mail.number + '')){
      cat(mail.name + ".email");
    }
  });
}
else if(program.grep){
  var args = program.args,
      second = args.length > 0 ? args[0]:false;
  grep(program.grep);
}
else if(program.edit || program.send){
  var file = program.edit || program.send;
  options.quiet = program.send ? true:false;
  if(/\.email$/.test(program.edit)){
    options.file = file;
    sendmail(options);
    return;
  }
  getEmails(function(mail){
    if(mail.number == file){
      options.file = mail.name;
      sendmail(options);
    }
  });
}
else{
  if(program.args[0]){
    fs.readFile(program.args[0], function(err, data){
      if(err) clog.error(err);
      options.content = data;
      sendmail(options);
    });
  }else{
    sendmail(options);
  }
}
